## 单例模式

### 什么是单例模式?

例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。
通过单例模式可以保证系统中，`应用该模式的类一个类只有一个实例。即一个类只有一个对象实例`

### 动机
对于系统中的某些类来说，只有一个实例很重要，例如，

* 一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；
* 一个系统只能有一个窗口管理器或文件系统；
* 一个系统只能有一个计时工具或ID(序号)生成器。
* 如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，
则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。

* 使用单例模式的时机是当实例存在多个会引起程序逻辑错误的时候。比如类似有序的号码生成器这样的东西，怎么可以允许一个应用上存在多个呢？

因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 
* 如何保证一个类只有一个实例并且这个实例易于被访问呢？

定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。
这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 

### 要点

* 1 是某个类只能有一个实例.
  单例模式的类只提供私有的构造函数

* 2 是它必须自行创建这个实例.
  类定义中含有一个该类的静态私有对象

* 3 是它必须自行向整个系统提供这个实例。
  该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。
  
### 优缺点

* **优点**

一、实例控制

单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。

二、灵活性

因为类控制了实例化过程，所以类可以灵活更改实例化过程。


* **缺点**

一、开销

虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。

二、可能的开发混淆

使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。

三、对象生存期

不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。

## java代码实现

#### 懒汉式

__不在系统加载时就创建类的单例，而是在第一次请求实例的时候再创建。__

* 缺点 : 执行速率慢

``` java
public class SingletonClass{
    private static SingletonClass instance=null;
    public static　synchronized　SingletonClass getInstance(){
        if(instance==null){
               instance=new SingletonClass();
        }
        return instance;
    }
    private SingletonClass(){
    }
}
```

* 测试

``` java
 SingletonClass instance = SingletonClass.getInstance();
 SingletonClass instance1 = SingletonClass.getInstance();
       
 if (instance == instance1) {
     System.out.println("同一个对象");
        }
```

输出结果: **同一个对象**

#### 饿汉式

__加载类的时候就会创建类的单例，并保存在类中。__

缺点: 占用较多的空间，因为其在类加载时就会完成实例化

``` java
public class Singleton{
    //在自己内部定义自己的一个实例，只供内部调用
    private static final Singleton instance = new Singleton();
    private Singleton(){
        //do something
    }
    //这里提供了一个供外部访问本class的静态方法，可以直接访问
    public static Singleton getInstance(){
        return instance;
    }
}
```
#### 双重加锁机制

``` java
public class Singleton{

    private static volatile Singleton instance=null;
    private Singleton(){
        //do something
    }
    public static  Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
     }
}

``` 

> 这个模式将同步内容下放到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。
这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，
假设有一百个线程，耗费的时间为100\*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。
所以如果面对`高并发`的情况，而且采用的是`懒汉模式`，最好的选择就是双重判断加同步的方式。


















