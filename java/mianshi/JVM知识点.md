
# 1 java内存区域

## 1.1 程序计数器
  
  * 线程私有。
  * 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
  
## 1.2 Java虚拟机栈
  
  * 为虚拟机执行java方法（也就是字节码）服务。
  * 线程私有。
  * 生命周期与线程相同。
  * 描述的是java方法执行的内存模型：用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

## 1.3 本地方法栈

  * 为虚拟机使用到的Native方法服务。

## 1.4 Java堆

 * Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
 * 所有的对象实例和数组都要在堆上分配。
 * Java堆是垃圾收集器管理的主要区域。
 * 物理上可以不连续，逻辑上连续。
 
## 1.5 方法区

  * 各个线程共享。
  * 用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
  
  
## 1.6 运行时常量池

  * 是方法区的一部分。
  * 用于存放编译期生成的各种字面量和符号引用。
  
  
 # 2 垃圾收集器
 
 ## 2.1 如何判断对象是否`存活` ?
 
 ### 2.1.1 引用计数算法
 
 给对象添加一个引用计数器，每当有一个地方引用他时，该计数器就加1，当引用失效时，该计数器就减一；任何时刻计数器值为0的对象都是不可再被引用的对象。
 
 ### 2.1.2 可达性分析算法
 
 通过一系列的称为"GC Roots" 的对象作为起始点，从这些节点开始向下搜素，搜索所走过的路径称为引用链，当一个对象到达GC Roots没有任何引用链相连，
 则证明此对象是不可用的。
 
 ## 2.2 垃圾收集算法
 
 ### 2.2.1 标记-清除算法
 
  * 分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。
  * 缺点 ：
      * 效率低
      * 标记清除之后产生大量不连续的空间碎片，可能会导致提前出发另一次CG
      
 ### 2.2.2 复制算法
 
  * 将可用内存划分为相等的两块，每次使用其中的一块。当着一块的内存使用完了，就将还存活着的对象复制到另一块上面，然后把已经使用过得内存空间
    清理掉。
   * 通常分为一块较大的，两块较小的。
   
 ### 2.2.3 标记-整理算法
 
   * 标记过程和标记-清除算法一样，后面则是将所有的存活对象都向一端移动，然后直接清理掉端边界以外的内存。
   
### 2.2.4 分带收集算法

  * 一般将java堆分为老年代和新生代，
    * 老年代使用 `标记-清理算法`或者`标记-整理算法`
    * 新生代 存活率低 一般使用`复制算法`
 
 ### 3 收集器
 
 ####3.1 G1收集器
 
 
  
